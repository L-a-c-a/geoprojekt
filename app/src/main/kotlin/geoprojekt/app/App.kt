/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package geoprojekt.app

import geoprojekt.utilities.*
import geoprojekt.db.*

import io.ktor.server.netty.*
import io.ktor.routing.*
import io.ktor.application.*
import io.ktor.http.*
import io.ktor.request.*
import io.ktor.response.*
import io.ktor.server.engine.*
import io.ktor.features.*
import io.ktor.gson.*

fun main() {
	embeddedServer(Netty, port = KONFIG.konf?.port ?: 8000) {
    install(ContentNegotiation) { gson {} }
		routing {
      get("/read")
      {
        val id = call.request.queryParameters["id"]?.toIntOrNull()?:0
        val typ = call.request.queryParameters["type"]
        if (id<1) call.respond(HttpStatusCode.BadRequest, "Invalid id, may be only positive integer")
        else
        {
          when (typ)
          {
            "polygon" ->
              { val answ = CRUD().getPGpolygon(id)
                if (answ.error==null)
                  if (answ.type==null || answ.coordinates==null) call.respond(HttpStatusCode.NotFound, "No $typ #$id found")
                  else call.respond(answ)
                else call.respond(HttpStatusCode.InternalServerError, answ.error!!.joinToString())
              }
            "point" -> 
              { val answ = CRUD().getPGpoint(id)
                if (answ.error==null)
                  if (answ.type==null || answ.coordinates==null) call.respond(HttpStatusCode.NotFound, "No $typ #$id found")
                  else call.respond(answ)
                else call.respond(HttpStatusCode.InternalServerError, answ.error!!.joinToString())
              }
            else -> call.respond(HttpStatusCode.InternalServerError, "Invalid type: $typ")
          }

        }
      }

      put("/create")
      {
        val typ = call.request.queryParameters["type"]
        when (typ)
        { "point" -> 
          {
            val pointObj = call.receive<GeoJsonPoint>()
            CRUD().putPGpoint(pointObj)
            ?. let{ call.respond("${it[0]} object(s) saved, new id = ${it[1]}") } 
            ?: call.respond(HttpStatusCode.InternalServerError, "Invalid input or internal error")
          }
          "polygon" -> 
          {
            val polygonObj = call.receive<GeoJsonPolygon>()
            CRUD().putPGpolygon(polygonObj)
            ?. let{ call.respond("${it[0]} object(s) saved, new id = ${it[1]}") } 
            ?: call.respond(HttpStatusCode.InternalServerError, "Invalid input or internal error")
          }
          else -> call.respond(HttpStatusCode.InternalServerError, "Invalid input")
        }
      }
      // TODO: pass data to CRUD in text format (with receiveText()) and CRUD will deserialize it as needed, so the "type" parameter is not needed

      post("/update")
      {
        val typ = call.request.queryParameters["type"]
        val id = call.request.queryParameters["id"]?.toIntOrNull()?:0
        if (id<1) call.respond(HttpStatusCode.InternalServerError, "Invalid id, may be only positive integer")
        else
          when (typ)
          { "point" -> 
            {
              val pointObj = call.receive<GeoJsonPoint>()
              CRUD().updPGpoint(id, pointObj)
              ?. let{ if (it[0]>0) call.respond("${it[0]} object(s) updated, id = ${it[1]}")
                      else call.respond(HttpStatusCode.NotFound, "No $typ #$id found")
                    } 
              ?: call.respond(HttpStatusCode.InternalServerError, "Invalid input or internal error")
            }
            "polygon" -> 
            {
              val polygonObj = call.receive<GeoJsonPolygon>()
              CRUD().updPGpolygon(id, polygonObj)
              ?. let{ if (it[0]>0) call.respond("${it[0]} object(s) updated, id = ${it[1]}")
                      else call.respond(HttpStatusCode.NotFound, "No $typ #$id found")
                    } 
              ?: call.respond(HttpStatusCode.InternalServerError, "Invalid input or internal error")
            }
            else -> call.respond(HttpStatusCode.InternalServerError, "Invalid input")
          }
      }

      delete("/delete")
      {
        val typ = call.request.queryParameters["type"]
        val id = call.request.queryParameters["id"]?.toIntOrNull()?:0
        if (id<1) call.respond(HttpStatusCode.BadRequest, "Invalid id, may be only positive integer")
        else
          when (typ)
          {
            "polygon" -> CRUD().delPGpolygon(id)
            "point" -> CRUD().delPGpoint(id)
            else -> arrayOf()
          } 
          ?.let { if (it.size==2)
                    if (it[0]>0) call.respond("${it[0]} object(s) deleted, id = ${it[1]}")
                    else call.respond(HttpStatusCode.NotFound, "No $typ #$id found")
                  else call.respond(HttpStatusCode.InternalServerError, "Invalid type: $typ")
                }
          ?: call.respond(HttpStatusCode.InternalServerError, "Invalid input or internal error")
      }

      post("/contains")
      {
        val id = call.request.queryParameters["id"]?.toIntOrNull()?:0
        if (id<1) call.respond(HttpStatusCode.BadRequest, "Invalid id, may be only positive integer")
        else
        {
          val pointObj = call.receive<GeoJsonPoint>()
          val (status, doesItContainIt) = CRUD().contains(id, pointObj)
          when (status)
          {
            HttpStatusCode.OK -> call.respond("Area #$id ${if (doesItContainIt) "CONTAINS" else "DOES NOT CONTAIN"} the given point")
            HttpStatusCode.NotFound -> call.respond(status, "Area #$id not found")
            else -> call.respond(status, "Invalid input or internal error")   //TODO: maybe specify further
          }
        }

      }

    }
	}.start(wait = true)
}
